\section{Développement de l'application}
Ce point du rapport est dédié au déroulement du développement de l'application \textit{Manabu}. J'expliquerai ce que j'ai mis en place point par point, en fonction des différentes parties de l'application. Je commencerai par quelques généralités concernant le programme, puis j'expliquerai le menu principal, et enfin les différents exercices. J'illustrerai au maximum mes propos par des screenshots des différents exercices.

\subsection{Généralités}
Ce que j'appelle généralités sont pour moi des décisions que j'ai prises et qui affectent l'application dans son ensemble, où simplement des points nécessitant d'être explicités pour une meilleure compréhension du développement de l'application.\\

Tout d'abord, avant de me lancer dans la création de \textit{Manabu}, j'ai suivi le premier tutoriel disponible sur le site officiel d'Android pour le développeurs, \textit{Building Your First App}\footnote{Building Your First App, \url{http://developer.android.com/training/basics/firstapp/index.html}, consulté en janvier et février 2015}. Ceci m'a permis de me familiariser avec le SDK Android et de connaître les bases de ce type de programmation.\\

Ensuite, il faut savoir que \textit{Manabu} est composée de 5 activités. Une activité, comme expliqué au point \textit{Outils et technologies utilisés} dans la définition d'Android Developer, représente un écran avec lequel l'utilisateur peut interagir. Dans la pratique, une activité est contenue dans une classe java qui lui est propre et associée avec un où plusieurs layouts. Dans le cas présent, j'ai considéré que mon application est constituée de 5 parties différentes. J'ai donc transcrit chacune d'entre elles en une activité. Celles-ci sont :
\begin{itemize}
\item la \textit{main activity}, autrement dit le menu principal. Il s'agit de l'écran d'ouverture de l'application.
\item l'activité de l'exercice \textit{Imagerie}.
\item l'activité de l'exercice \textit{Lecture flash}.
\item l'activité de l'exercice \textit{Anagrammes}.
\item l'activité de l'exercice \textit{Écouter le son}.\\
\end{itemize}

L'activité contenant le menu principal ne contient qu'un seul layout. Les autres activités, celles des exercices, en contiennent quant à elles plusieurs. Trois layouts sont communs au quatre exercices. Il s'agit du layout de menu de démarrage, contenant notamment le choix du niveau, du layout d'affichage des règles du jeu et du layout de fin d'exercice.\\

Par ailleurs, j'ai intégré \textit{OpenDyslexic} en tant que police principale de \textit{Manabu}. Ça n'a pas été la tâche la plus simple. J'ai tout d'abord essayé de modifier la police d'un élément (pensant par la suite pouvoir l'appliquer à toute l'application) via la méthode "classique". C'est-à-dire aller chercher la police dans un dossier et l'appliquer à chaque élément voulu. Cette méthode s'est révélée lourde à mettre en place. C'est en voulant intégrer par la suite la librairie \textit{Calligraphy} de ChrisJenx\footnote{Disponible gratuitement sur GitHub à l'adresse \url{https://github.com/chrisjenx/Calligraphy}.} permettant d'utiliser une police pour tout l'application facilement que j'ai rencontré le problème avec Maven dans Eclipse. J'ai donc, comme dit précédemment, changé d'IDE pour Android Studio. Gradle a quant à lui ajouté sans problème la librairie à la liste des dépendances.

\subsection{Le menu principal}
Le menu principal représente l'activité de base de l'application, celle depuis laquelle peuvent être démarrées les autres activités contenant les exercices. Le layout formant ce menu est relativement simple. Il s'agit de quatre boutons disposés en rectangle. Chacun des boutons lance bien évidemment un des exercices.\\

Pour chaque bouton, il m'a fallu implémenter une fonction spécialisée permettant de lancer la nouvelle activité correspondant à l'exercice désiré.
Lancer une nouvelle activité se fait à l'aide d'un \textit{intent}. Un intent est une sorte de lien de communication pour le système Android. Celui-ci signale qu'il se passe quelque chose. Dans le cas présent, l'intent signale que l'activité du menu principal va en démarrer une autre.\\

Enfin, je tiens à mentionner qu'il n'est pas possible de lancer les activités de plusieurs exercices à la fois. En effet, lorsqu'un exercice est lancé depuis le menu, l'activité en cours représentée passe du menu à l'activité de l'exercice, l'activité menu étant alors en attente. Il faut quitter l'exercice, et donc l'activité, pour revenir au menu et pouvoir en démarrer une autre.

%La toute première activité que j'ai mise en place a été le squelette de l'application. Par squelette, je veux dire le menu de base, ainsi que la manière dont chaque exercice serait lancé, et le menu présent pour chaque exercice (semblable pour tous). \\

%Mettre en place le layout du menu principal n'a pas été trop difficile, celui-ci étant simplement composé de quatre boutons disposés en rectangle, ceux-ci lançant une nouvelle \textit{activity} pour chaque exercice. La tâche s'est compliquée lorsque j'ai voulu faire en sorte que la police principale de l'application devienne \textit{OpenDyslexic}, comme me l'avait conseillé la logopède. J'ai tout d'abord essayé de modifier la police d'un élément (pensant par la suite pouvoir l'appliquer à toute l'application sous forme de fonction) via la méthode "classique". C'est-à-dire aller chercher la police dans un dossier et l'appliquer à chaque élément voulu. Cette méthode n'a pas fonctionné, et s'est révélée être lourde à mettre en place. Je me suis alors tournée vers une librairie externe : \textit{Calligraphy} de ChrisJenx\footnote{Disponible gratuitement sur GitHub à l'adresse \url{https://github.com/chrisjenx/Calligraphy}.}.\\

%Le mode d'emploi d'ajout de \textit{Calligraphy} étant clair, j'ai décidé d'intégrer cette librairie via Maven dans mon projet Eclipse. Pour ce faire, il me fallait installer le plugin Maven et convertir ensuite mon projet. J'ai à ce stade du travail rencontré le problème avec Eclipse décrit précédemment. De ce fait, j'ai changé mon fusil d'épaule pour continuer mon projet avec Android Studio. Ce dernier utilisant Gradle, plus facile d'utilisation que Maven, il m'a suffit d'ajouter une ligne dans le fichier spécifiant les dépendances pour importer la librairie. J'ai alors pu utiliser la police voulue pour mon application en suivant les instructions fournies par le créateur de la librairie.\\



\subsection{L'exercice \textit{Imagerie}}
L'exercice \textit{Imagerie} est le premier que j'ai choisi d'implémenter. Il s'agit de mon exercice favori, car il m'a permis d'exprimer ma créativité au travers des dessins réalisés. Pour le premier niveau, j'ai choisi de partir sur la version la plus simple des fichiers Freinet : une image affichée avec un mot à mémorisé, et puis sur base de la même image retrouver ce mot parmi trois propositions.\\

Afin de réaliser ce niveau 1, il m'a fallu définir une liste de mots allant être utilisés. J'ai défini une liste d'une vingtaine de mots à illustrer. Pour chacun de ceux-ci, j'ai également choisi deux autres mots ressemblant à la bonne réponse pour faire office de fausses réponses. J'ai réalisé les illustrations dans un style de dessin simple, à l'aide du logiciel de dessin vectoriel Adobe Illustrator. \\

%Pour le paragraphe juste en dessous : illustrer avec screenshots

En ce qui concerne la partie programmation de l'exercice, celui-ci contient deux layouts XML qui lui sont spécifiques. Le premier layout présente l'affichage de l'image et du mot à retenir, ainsi qu'un bouton "\textit{Mémorisé}". Le bouton mémorisé permet de passer au layout suivant. Ce dernier est constitué de la même image que pour le premier layout, ainsi que trois boutons représentant le choix des mots.\\

Concernant le fonctionnement de l'exercice en lui-même, ceci a été défini dans la classe java correspondant à l'activité. Tout d'abord, il faut savoir qu'en Android, les chaînes de caractères sont stockées dans un fichier \textit{strings.xml}. Les autres types de ressources sont également placées dans des dossiers spécialisés. Pour les images, ces dossiers s'appellent \textit{drawable}. Il existe plusieurs dossiers \textit{drawable}, stockant respectivement les même images correspondant cependant à une résolution d'écran différente. Pour accéder à l'une des ressources, que ce soit chaîne de caractères, image, ou autre, le nom identifiant celle-ci est requis. Sachant cela, j'ai utilisé une nomenclature permettant de lier facilement les mots et les images leur correspondant. L'image et le mot correct qui lui est attribué portent le même nom. Celui-ci est de type \textit{img\_XX} où \textit{XX} correspond au numéro identifiant le couple. Les deux réponses incorrectes sont quand à elles nommées dans le fichiers \textit{strings.xml} \textit{img\_XX\_1} et \textit{img\_XX\_2}.\\

Le principe utilisé pour \textit{Imagerie} est simple. L'image affichée est choisie au hasard parmi les possibilités. Pour ce faire, je génère un nombre random compris entre 0 et le nombre d'images - 1 (20 dans le cas présent). Ce nombre est alors concaténé à une chaîne de caractère afin de former le nom de la ressource que le système doit aller rechercher. Étant donné que l'exercice est constitué de 10 images à la suite, je vérifie également que la ressource n'a pas déjà été utilisée lors de la série. À partir de cette chaîne de caractères, l'image et le mot peuvent être chargés et affichés sur le premier layout. Pour le second layout, celui proposant les choix, l'ordre d'affichage des réponses dans les boutons est également défini au hasard. J'applique alors un random entre 0 et 2. L'ordre de sortie des nombres me donne l'ordre d'affichage des réponses. Pour que le système puisse aller rechercher les mauvaises réponses, je concatène la chaîne précédente avec le numéro attribué à la réponse.\\

 %Une fois les layouts définis, la première étape a été d'afficher une image précise avec son mot, de la valider, puis de passer au choix multiple pour cette image. Dans l'arborescence d'Android, les images sont stockées dans des répertoires appelés \textit{drawable}, et les chaînes de caractères dans un fichier nommé \textit{strings.xml}. Sachant cela, et afin de me faciliter la tâche, j'ai donné à l'image et au mot le même nom. Ce nom est de type \textit{img\_XX} où \textit{XX} correspond au numéro identifiant l'image. Dans le cas du niveau 1, j'ai pour ce TFE créé 21 images. Les numéros s'étendent donc de 0 à 20. Pour les deux réponses incorrectes, je les ai respectivement nommées \textit{img\_XX\_1} et \textit{img\_XX\_2}. Le choix de cette nomenclature s'expliquera dans le paragraphe suivant. En ce qui concerne l'étape dont je parle actuellement, elle a été réalisée avec une seule image, hardcodée.\\
 
%Par après, j'ai rajouté le choix de l'image au hasard, ainsi que l'affichage de l'ordre des réponses au hasard. C'est ici que le choix de la nomenclature prend tout son sens. En effet, le \textit{XX} précédemment cité. Celui-ci est choisi au hasard dans l'intervalle spécifié, pour ensuite être concaténé afin de former la chaîne de caractère correspondant aux identifiants de l'image et du mot. Enfin, j'ai implémenté une boucle afin que l'exercice soit une série de 10, tout en m'assurant que les mots ne puissent pas être deux fois identiques dans cette série en mémorisant ceux piochés précédemment.\\

Concernant les réponses proposées pour l'exercice, il m'a fallu trouver un système pour que l'enfant qui joue sache clairement s'il s'est trompé où s'il a réussi. J'ai pour ce faire mis en place un \textit{toast} qui apparaît lorsqu'on clique sur un des boutons de réponse. En Android, un \textit{toast} est une sorte de notification qui se surimprime sur l'écran pendant un temps défini. Le plus souvent, il s'agit d'un message simple. Parfois, on y retrouve une image, pour ce faire, un layout spécifique est créé pour le \textit{toast}. Je voulais mettre en place un toast avec une image et un texte : "V" et "Bien joué !" pour la bonne réponse, "X" et "Essaye encore !" pour la mauvaise. J'ai donc créé le layout nécessaire, utilisable dans les deux cas, car je passe l'identifiant de l'image et le message en paramètre à l'aide d'une fonction. En fonction du type de réponse, j'assigne au bouton correspondant l'action d'affichage du \textit{toast} "réussi" ou "perdu". Par la suite, j'ai fait de ce \textit{toast} une fonction utilisable dans les différentes \textit{activités} qui composent mon application.\\

L'exercice \textit{Imagerie} n'a pas été trop difficile à mettre en place. Une fois la logique définie, j'ai aisément pu implémenter les fonctions nécessaires. Toutefois, il s'agissait du premier exercice, j'ai donc du appréhender certaines notions. J'ai par exemple appris à lier une image ou une chaîne de caractères à un élément du layout xml à l'aide du code java afin de pouvoir modifier ce dernier.

\subsection{L'exercice \textit{Lecture flash}}
L'exercice \textit{Lecture flash} est le deuxième que j'ai mis en place pour l'application. Comme pour l'exercice précédent, j'ai d'abord commencé par le premier niveau de difficulté. Dans le cas présent, la difficulté entre les niveaux se situera principalement au niveau de la vitesse de lecture. Pour ce premier niveau, j'ai choisi de laisser la possibilité d'afficher le mot pendant 20 secondes.\\

Les mots utilisés pour cet exercices n'ont pas été choisis au hasard. En effet, suivant les conseils de Laurence Henrion et commen prévu dans le cahier des charges, j'utilise le VOB (Vocabulaire Orthographique de Base). Pour rappel, il s'agit d'une liste de vocabulaire que les enfants doivent maîtriser à la fin de chaque cycle. Dans le cadre de l'application, j'utilise le VOB du degré inférieur, qui correspond aux mots devant être connus fin de deuxième primaire (cf. annexe \ref{listeVob}). J'ai donc recopié les 480 mots constituant le VOB du cycle inférieur dans le fichier \textit{strings.xml}. Comme précédemment, afin de faciliter le choix des mots de manière aléatoire, les noms sont identiques et différenciés par un nombre. La nomenclature de ceux-ci est \textit{str\_XXX}. \\

Pour l'interface graphique de cet exercice, il me fallait 3 layouts :
\begin{itemize}
\item un premier lors du démarrage, afin de choisir le nombre de secondes d'affichage des mots.
\item un deuxième pour l'affichage du mot en lui-même. Très simple car il est constitué d'un seul élément.
\item Un troisième et dernier avec un champ texte éditable et un bouton de vérification, qui est chargé une fois que le temps d'affichage du mot est écoulé.\\
\end{itemize}

Du point de vue de la programmation java, j'ai créé un \textit{NumberPicker} personnalisé pour définir le temps d'affichage du mot dans le premier layout. Un \textit{NumberPicker} est un élément que l'on peut ajouter tel quel à un layout et qui permet de sélectionner un nombre dans un intervalle défini. Or, l'élément en tant que tel est très peu personnalisable. De ce fait, j'ai choisi de mettre en place le mien, ce qui est facile à faire. J'ai simplement aligné deux boutons avec un champ texte non éditable entre eux. J'ai assigné au bouton "-" la décrémentation du nombre dans le champ texte, et au "+" l'incrémentation.\\

La programmation concernant le fonctionnement de l'exercice en lui même est similaire à ce qui a été mis en place pour l'exercice \textit{Imagerie}. J'ai repris le principe de génération d'un nombre au hasard à concaténer par la suite une la chaîne de caractères afin d'obtenir le nom de la ressource. Ainsi, le layout d'affichage récupère la ressource, et affiche le temps pendant le temps récupéré depuis le \textit{NumberPicker} personnalisé. Le layout de vérification de l'écriture du mot à quand à lui en mémoire le mot précédemment affiché, et le compare avec ce qui est entré dans le champ texte par l'enfant.\\

%La suite de la programmation s'est déroulée de manière fluide également : l'affichage du mot le temps voulu (celui-ci récupéré du \textit{NumberPicker} codé au layout précédent), le choix au hasard du mot parmi le VOB, et la vérification du mot post-lecture. Pour le choix du mot au hasard, j'ai réutilisé le code de l'exercice \textit{Imagerie} et le modifiant pour qu'il corresponde à l'exercice.\\

Avec la développement expliqué ci-dessus, l'exercice en lui-même est fonctionnel. J'ai implémenté en supplément un clavier propre à \textit{Manabu}. Ceci m'a été demandé par les enfants sur lequels j'ai eu l'occasion de tester l'application, et notamment cet exercice (cf. point \ref{testFlash}). Ceux-ci préféraient avoir un clavier pour lequel il ne devaient pas réapprendre l'ordre des lettres, et donc un de type \textit{alphabet} plutôt qu'un \textit{azerty}. Afin de mettre en place mon propre \textit{SoftKeyboard}, je me suis inspirée du tutoriel de Martin Pennings et j'ai téléchargé le code source disponible sur la page du celui-ci\footnote{Maarten Pennings,\textit{Android development: Custom keyboard}, \url{http://www.fampennings.nl/maarten/android/09keyboard/index.htm}, consulté le 18 mai 2015}. Après avoir essayer de compléter mon code sur base du tutoriel seul, sans grand succès, j'ai décidé d'intégrer le code source précédemment téléchargé à mon projet.\\

Enfin, le code source de Martin Pennings étant pour mettre en place un \textit{Softkeyboard} hexadécimal, je ne l'ai pas gardé tel quel. J'ai remplacé le seul layout fourni de base par quatre nouveau layouts composants mon clavier :
\begin{itemize}
\item un layout avec les 26 lettres de l'alphabet en minucule
\item un layout avec les 26 lettres de l'alphabet en majuscule
\item un layout avec les lettres accentuées en minuscule et la ponctuation
\item un layout avec les lettres accentuées en majuscule et la ponctuation
\end{itemize}
De ce fait, j'ai également modifié certaines parties du code précédemment intégré afin de l'adapter aux besoins de Manabu.\\

La mise en place du premier niveau de l'exercice \textit{Lecture Flash} en lui-même s'est donc déroulée sans encombre. Comme expliqué ci-dessus, la partie la plus ardue a été l'implémentation du clavier \textit{alphabet} à partir du code de quelqu'un d'autre.\\\\
	
\subsection{L'exercice \textit{Anagrammes}}
\textit{Anagrammes} est le troisième exercice que j'ai implémenté. C'est également durant la mise en place de celui-ci que j'ai pu faire tester l'application sur des enfants (cf. \ref{testEnfants}).\\

En terme de layout, il s'agit de l'exercice qui en nécessite le moins. En effet, je n'ai mis qu'un layout en place. Par défaut, celui-ci contient uniquement un bouton permettant de ré-écouter le mot dont il faut remettre les lettres dans l'ordre. Les autres éléments de ce layout sont ajoutés de manière programmée lors de la génération d'un nouvel anagramme.\\

Bien que mettre en place le layout ait été un jeu d'enfant, je ne peux pas dire que c'était également le cas pour la programmation. Je m'y suis reprise plusieurs fois afin de parvenir à un résultat correct et le plus proche possible de ce que j'avais imaginé. Les difficultés rencontrées lors du développement de cet exercice seront expliquées par la suite, au point \ref{diff} \textit{Difficultés rencontrées}. Voici donc l'explication des actions programmées pour cet exercice.\\

Tout d'abord, j'ai repris le bout de code de l'exercice \textit{Lecture flash} servant à aller chercher une chaîne de caractères au hasard. En effet, j'utilise également le VOB pour les anagrammes. Pour le niveau 1, je limite le mot à minimum 3 et maximum 5 lettres. Les niveaux suivants augmentent bien entendu le nombre de lettres, ce qui les rends plus difficiles. Ensuite, je mélange les lettres du mot au hasard pour former l'anagramme\textit{La définition d'anagramme est un mot formé des mêmes lettres que le mot de base. Cependant, ici, je mélange toute les lettres sans chercher à ce qu'elles forment un autre mot}.\\

Ensuite, j'ajoute au layout de nouveaux boutons. Pour être exacte, j'ajoute deux fois plus de boutons qu'il y a de lettres dans le mot. La moitié de ces boutons sont ajoutés sous formes de \textit{cases de validation}, blanches. Ceci signifie que les lettres mélangées viendront une par une se fixer sur l'un de ceux-ci pour reformer le mot original. La seconde moitié des boutons est évidemment dédiée aux lettres dans le désordre. Une lettre correspond à un bouton. Les voyelles sont affichées sur un fond orange, tandis que les consonnes sont sur fond vert. Ceci permet à l'enfant de discriminer une première fois les lettres.\\

La validation de la remise en ordre des lettres est l'étape cruciale de cet exercice. Les boutons contenant les lettres mélangées ont tous un \textit{on touch listener}. Ce dernier leur permet de suivre le mouvement du doigt qui les guidera jusqu'à la bonne \textit{case de validation}. Afin de valider la position d'une lettre sur une de ces cases, j'ai mis en place quelques petites astuces. En premier lieu, les \textit{cases de validation} contiennent la lettre correcte qui doit s'y trouver, ainsi qu'un booléen signifiant si cette lettre a déjà été placée ou non. Les boutons des lettres à réorganiser contiennent aussi un booléen pour savoir si ils ont trouvé la bonne \textit{case de validation}. Lors du mouvement d'une lettre, si celle-ci se trouve au-dessus de la case qui lui correspond, la position de la lettre deviendra identique à celle de la case et le mouvement ne sera alors plus possible. Le mouvement est empêché grâce aux deux booléens ayant alors pris la valeur \textit{true}. Une fois l'anagramme complété, le suivant sera lancé, et ainsi de suite pour 10 anagrammes.\\

D'autre part, le son est une composante importante de l'exercice. Lors du lancement de chaque nouvel anagramme, l'enregistrement du mot est joué une fois afin d'indiquer à l'enfant le mot à reconstruire. Ceci m'a été demandé par des enfants lors du test (cf. point \ref{testAna}). Un bouton leur permet également de ré-écouter le mot à tout instant. De plus, j'ai ajouté un petit extra, qui selon moi donne un peu plus de consistance et de fun à l'exercice. Lorsqu'une lettre est placée correctement sur sa case, un son est joué. Celui-ci valide l'action, et encourage l'enfant car celui-ci voit qu'il progresse.\\

Enfin, je peux confirmer que cet exercice m'a demandé plus de ressources que les deux précédents. Il a été plus chronophage également. Malgré cela, il a été très intéressant à développer, car il m'a forcé à imaginer des astuces et un algorithme plus complexe que je ne l'aurais imaginé afin de parvenir à mes fins.

\subsection{L'exercice \textit{Ecouter le son}}
